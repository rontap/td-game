import {getState} from "./State";
import {jsobj} from "../app/util";
import {LineId, NodeId} from "../node/Line";
// de and re serialise content
/* eslint import/no-webpack-loader-syntax: off */


class Serialiser {
    toID(id: NodeId | LineId): string {
        return "id-" + id;
    }

    toJSON(): jsobj[] {
        const parsedNodes = getState().nodes.map(node => {
            console.log(node, '<<');
            const nodeProps = node.nodeProps;
            return {
                ptr: node,
                name: this.toID(node.ID),
                [nodeProps.config?.self]: {
                    ...node._configValues,
                },
                input: node.prevNodes.map(this.toID),
                output: node.nextNodes.map(this.toID)
            }
        });
        console.log(parsedNodes);
        return parsedNodes;
    }

    dropPtrFromJSON(jsobjWithPtr: jsobj[]): jsobj[] {
        return jsobjWithPtr
            .map(nodeJSON => {
                delete nodeJSON.ptr;
                return nodeJSON;
            })
    }

    fromJSON(obj: jsobj) {
        // todo , fill nodes
        // todo fill lines
        // todo initial fillup of store.?


    }

    toTopLevel(transform: jsobj[]): jsobj {
        return {
            description: 'generated by STS',
            transform
        }
    }

    fromTopLevel(obj: jsobj): jsobj {
        return {}
    }


    // SVG

    toSvgCreate() {
        const css = require('!!raw-loader!../svg.css').default;
        const cssExportOnly = require('!!raw-loader!../svgExprted.css').default;

        const parsedNodes = this.toJSON();
        parsedNodes.forEach(nodeJSON => {
            const boxedItem = document.querySelector(`.boxedCode-${nodeJSON.ptr.ID}`);
            if (boxedItem) {
                boxedItem.innerHTML = JSON.stringify(nodeJSON, null, 2);
            }
        })

        const svgRoot = document.getElementById("svgRootCont")!.innerHTML;

        const parsedCss = css.replace(/\n/g, " ");
        const parsedCssExport = cssExportOnly.replace(/\n/g, " ");
        const svgRootCss = svgRoot
            // slicing off the end SVG tag
            .slice(0, -6)
            // add the CSS required for the SVG to look nice
            .concat(`<style>${parsedCss}</style>`)
            // add the export only CSS and close down SVG
            .concat(`<style>${parsedCssExport}</style></svg>`)
            // replace <input>-tags with XML valid <input/> tags
            .replace(/<input(.*?)(>)/gm, "<input$1\/>")
            // replace <br>-tags with XML valid <br/> tags
            .replace(/<br(.*?)(>)/gm, "<br$1\/>");
        console.log('nl',
            this.toTopLevel(
                this.dropPtrFromJSON(
                    this.toJSON()
                )
            )
        );

        return svgRootCss;
    }

    toSvg(download: boolean = false) {
        const svg: string = this.toSvgCreate();
        const blob: Blob = new Blob([svg], {type: 'image/svg+xml'});
        const objectUrl = URL.createObjectURL(blob);
        const aElement = document.createElement('a');

        if (download) {
            aElement.setAttribute('download', 'fn.svg');
        } else {
            aElement.setAttribute('target', '_blank');
        }

        aElement.setAttribute('href', objectUrl);
        aElement.click();
        aElement.remove();
    }
}

const SerialiserInst = new Serialiser();

export {SerialiserInst};
// @ts-ignore
window.SI = SerialiserInst;
export default Serialiser;